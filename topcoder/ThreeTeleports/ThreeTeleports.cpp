#include <string>
#include <cstdlib>
#include <cstdio>
#include <iostream>
#include <vector>

using namespace std;

typedef vector<int> teleport;

class ThreeTeleports {
    public:
        int shortestDistance(int xMe, int yMe, int xHome, int yHome, vector<string> teleports);
    private:
        void shortestDistanceComb(int index, int remainingTeleports);
        void shortestDistancePerm(int index);
        void shortestDistanceTerminalSwitch(int index);
        long long xStart;
        long long yStart;
        long long xEnd;
        long long yEnd;
        long long minimumTime;
        vector<teleport> teleportSet; //set of all the teleports for the problem
        vector<int> teleportSubsetBits; //bit string designatng a subset of teleportSet
        vector<teleport> teleportSubset; //the subset generated by the bit string
};


/* 
    Recursive function that takes a one of the permutations of a teleport subset
    and generates all permutations of this subset for transpositions of the 'terminals' of the 
    teleports. After generating each permutation, the transposition permuted subset is
    evaluated for to see if this subset takes less time than the current minimum. 
*/
void ThreeTeleports::shortestDistanceTerminalSwitch(int index) {
    int i;
    int temp;
    long long timeTotal = 0;
    int xCurrent = xStart;
    int yCurrent = yStart;

    //if we reach the end of the subset, evaluate how much time it take using the path
    //designated by this subset, if we find a new minimum time, set minimumTime to that
    if(index == teleportSubset.size()) {

        for(i = 0; i < teleportSubset.size(); i++) {
            if(xCurrent >= teleportSubset[i][0]) {
                timeTotal += xCurrent - teleportSubset[i][0];
            }
            else {
                timeTotal += teleportSubset[i][0] - xCurrent;
            }
            if(yCurrent >= teleportSubset[i][1]) {
                timeTotal += yCurrent - teleportSubset[i][1];
            }
            else {
                timeTotal += teleportSubset[i][1] - yCurrent;
            }
            xCurrent = teleportSubset[i][2];
            yCurrent = teleportSubset[i][3];
            timeTotal += 10;
            
        }

        if(xCurrent > xEnd) {
            timeTotal += xCurrent - xEnd;
        }
        else {
            timeTotal += xEnd - xCurrent;
        }

        if(yCurrent > yEnd) {
            timeTotal += yCurrent - yEnd;
        }
        else {
            timeTotal += yEnd - yCurrent;
        }

        if(timeTotal < minimumTime) minimumTime = timeTotal;
    }

    //recursively generate every subset permutation according to whether or not the
    //original start-end teleport coordinates are transposed or not
    else {

        shortestDistanceTerminalSwitch(index + 1);

        temp = teleportSubset[index][0];
        teleportSubset[index][0] = teleportSubset[index][2];
        teleportSubset[index][2] = temp;

        temp = teleportSubset[index][1];
        teleportSubset[index][1] = teleportSubset[index][3];
        teleportSubset[index][3] = temp;

        shortestDistanceTerminalSwitch(index + 1);

        temp = teleportSubset[index][0];
        teleportSubset[index][0] = teleportSubset[index][2];
        teleportSubset[index][2] = temp;

        temp = teleportSubset[index][1];
        teleportSubset[index][1] = teleportSubset[index][3];
        teleportSubset[index][3] = temp;
        
    }
}

/*
    generate every permutation of the current teleportSubset and then
    calls the function that generates the teleport terminal transposed subsets
    and evaluates the minimum times
*/
void ThreeTeleports::shortestDistancePerm(int index) {
    int i = index;
    
    teleport temp;

    //if the permutation is complete, call the recursive function that generates
    //all permutations of teleport terminal transpositions and evaluates the minimum times
    if(i == teleportSubset.size()) {
        shortestDistanceTerminalSwitch(0);
    }
    //if the transposition isnt complete, perform a temporary transposition and 
    //the recursive function
    else {
        for(i; i < teleportSubset.size(); i++) {
            temp = teleportSubset[i];
            teleportSubset[i] = teleportSubset[index];
            teleportSubset[index] = temp;

            shortestDistancePerm(index + 1);

            temp = teleportSubset[i];
            teleportSubset[i] = teleportSubset[index];
            teleportSubset[index] = temp;
        }
    }
}

/*
    generates all subsets of the teleportSet and calls the function that
    permutes each subset
*/
void ThreeTeleports::shortestDistanceComb(int index, int remainingTeleports) {

    //if the number of teleports left to 'pick' is 0, then we have a subset
    //as represented by a bit string, we then use this bit string to generate a subset
    //of teleports 
    if(remainingTeleports == 0) {
        for(int i = 0; i < teleportSubsetBits.size(); i++) {
            if(teleportSubsetBits[i] == 1) {
                teleportSubset.push_back(teleportSet[i]);
            }
        }
        shortestDistancePerm(0);
        teleportSubset.clear();
    }

    //if we have more teleports left to pick than remaining indexes to represent them
    //in out bit string, we return as this would be an invalid subset
    else if(teleportSubsetBits.size() - index < remainingTeleports) return;

    //if we havent finished generating the subset, and what we have so far is valid,
    //recursively call the function with and without the bits set in order to 
    //continue generating the bit string
    else {
        teleportSubsetBits[index] = 1;
        shortestDistanceComb(index + 1, remainingTeleports - 1);
        teleportSubsetBits[index] = 0;
        shortestDistanceComb(index + 1, remainingTeleports);
    }
}

/*
    wrapper function that parses the input data into our variables and data structures 
    calls the first recursive function which generates the subsets of the teleports
*/
int ThreeTeleports::shortestDistance(int xMe, int yMe, int xHome, int yHome, vector<string> teleports) {
    int x1, y1, x2, y2, i;

    teleport teleport; //holds a set of four coordinates as ints which desegnates a teleport

    /* set start and end coordinates to our class variables */
    xStart = xMe;
    yStart = yMe;
    xEnd = xHome;
    yEnd = yHome;

    minimumTime = 36854775807; //minimum time is larger than any possible solution so finding
                                //a minimum from generates solutions is easy

    /*
        parse each input teleport into a teleport set
    */
    for(i = 0; i < teleports.size(); i++){
        sscanf(teleports[i].c_str(), "%d %d %d %d", &x1, &y1, &x2, &y2);
        teleport.push_back(x1);
        teleport.push_back(y1);
        teleport.push_back(x2);
        teleport.push_back(y2);
        teleportSet.push_back(teleport);
        teleport.clear();
    }

    //create a bit string that will be used to generate the subsets
    for(i = 0; i < teleportSet.size(); i++) {
        teleportSubsetBits.push_back(0);
    }
    
    //call the subset generating recursive function for every number of
    //teleports that could be in the subset in order to generate all possible subsets
    for(i = 0; i <= teleportSet.size(); i++) {
        shortestDistanceComb(0, i);
    }

    //clear the data for the next problem
    teleportSet.clear();
    teleportSubsetBits.clear();
    teleportSubset.clear();

    return minimumTime;
}

int main() {

    //testing all the test cases from topcoder and one of my own
    ThreeTeleports t;
    vector<string> teleports;


    teleports.push_back("1000 1001 1000 1002");
    teleports.push_back("1000 1003 1000 1004");
    teleports.push_back("1000 1005 1000 1006");
    cout << t.shortestDistance(3, 3, 4, 5, teleports) << endl;
    
    teleports.clear(); 
    teleports.push_back("1 1 18 20");
    teleports.push_back("1000 1003 1000 1004");
    teleports.push_back("1000 1005 1000 1006");
    cout << t.shortestDistance(0, 0, 20, 20, teleports) << endl;

    teleports.clear(); 
    teleports.push_back("1000 1003 1000 1004");
    teleports.push_back("18 20 1 1");
    teleports.push_back("1000 1005 1000 1006");
    cout << t.shortestDistance(0, 0, 20, 20, teleports) << endl;

    teleports.clear(); 
    teleports.push_back("1000 1003 1000 1004");
    teleports.push_back("3 3 10004 20002");
    teleports.push_back("1000 1005 1000 1006");
    cout << t.shortestDistance(10, 10, 10000, 20000, teleports) << endl;

    teleports.clear(); 
    teleports.push_back("3 10 5200 4900");
    teleports.push_back("12212 8699 9999 30011");
    teleports.push_back("12200 8701 5203 4845");
    cout << t.shortestDistance(3, 7, 10000, 30000, teleports) << endl;

    teleports.clear(); 
    teleports.push_back("0 1 0 999999999");
    teleports.push_back("1 1000000000 999999999 0");
    teleports.push_back("1000000000 1 1000000000 999999999");
    cout << t.shortestDistance(0, 0, 1000000000, 1000000000, teleports) << endl;

    teleports.clear(); 
    teleports.push_back("1000 1003 1800 2055");
    teleports.push_back("1000 1003 1000 1004");
    teleports.push_back("1000 1005 1000 1006");
    cout << t.shortestDistance(0, 0, 0, 0, teleports) << endl;
    

    return 0;
}
